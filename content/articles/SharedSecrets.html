<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Your page title here :)</title>
  <meta name="description" content="">
  <meta name="author" content="">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/main.css"/>
<style>
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #303030; color: #cccccc; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; }
td.sourceCode { padding-left: 5px; }
pre, code { color: #cccccc; background-color: #303030; }
code > span.kw { color: #f0dfaf; } /* Keyword */
code > span.dt { color: #dfdfbf; } /* DataType */
code > span.dv { color: #dcdccc; } /* DecVal */
code > span.bn { color: #dca3a3; } /* BaseN */
code > span.fl { color: #c0bed1; } /* Float */
code > span.ch { color: #dca3a3; } /* Char */
code > span.st { color: #cc9393; } /* String */
code > span.co { color: #7f9f7f; } /* Comment */
code > span.ot { color: #efef8f; } /* Other */
code > span.al { color: #ffcfaf; } /* Alert */
code > span.fu { color: #efef8f; } /* Function */
code > span.er { color: #c3bf9f; } /* Error */
code > span.wa { color: #7f9f7f; font-weight: bold; } /* Warning */
code > span.cn { color: #dca3a3; font-weight: bold; } /* Constant */
code > span.sc { color: #dca3a3; } /* SpecialChar */
code > span.vs { color: #cc9393; } /* VerbatimString */
code > span.ss { color: #cc9393; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { } /* Variable */
code > span.cf { color: #f0dfaf; } /* ControlFlow */
code > span.op { color: #f0efd0; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #ffcfaf; font-weight: bold; } /* Preprocessor */
code > span.at { } /* Attribute */
code > span.do { color: #7f9f7f; } /* Documentation */
code > span.an { color: #7f9f7f; font-weight: bold; } /* Annotation */
code > span.cv { color: #7f9f7f; font-weight: bold; } /* CommentVar */
code > span.in { color: #7f9f7f; font-weight: bold; } /* Information */
</style>
</head>
<body>
  <nav class="navigation sticky">
    <div class="container">
      <div class="logo">
        <a href="/">holderbaum.io</a>
      </div>
    </div>
  </nav>
  <header class="main-header section-dark">
    <div class="container">
      <h1>Managing Team Secrets Effectively</h1>
      <hr class="headline-separator"/>
    </div>
  </header>

  <section class="article-details-section">
  <div class="container">
<!--- Let me start with a question: -->
<p>What are shared secrets? They are basically all the secret things you, your team and your servers have to know. And most modern web applications integrate with different services one way or another. Could be some databases, other web services, or third-party APIs. Often enough, you either need credentials, some token or a certificate to establish a trusted connection to these services.</p>
<p>Handling such secrets in a working team and during deployments can be a challenging and sometimes even intimidating task. We want to explore some directly applicable techniques that can help us to simplify this.</p>
<p>There are several approaches to handling secrets in an application. The oldest one being: simply having constants in your source code.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> PASSWORD <span class="op">=</span> <span class="st">&#39;sn4k3oil&#39;</span></code></pre></div>
<p>While this immediately solves the problem of keeping secret information in sync between your team members, it can not be considered a secure option. First of all, everyone who gets access to the source code will also be able to read your secrets. Furthermore, stuff like key-rotation can become tedious, since you would have to change, commit and deploy your actual source code to do so. And besides that, it becomes hard to deploy the same code to more than one location (e.g. staging and production).</p>
<p>An evolved alternative to this could be the storage of secrets in configuration files which are not checked into version control:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> PASSWORD <span class="op">=</span> yaml
  .<span class="at">load</span>(<span class="va">fs</span>.<span class="at">readFileSync</span>(<span class="st">&#39;secrets.yml&#39;</span>))
  .<span class="at">password</span></code></pre></div>
<p>This solves at least the pending issue of having clear text secrets in source code – but it generates new challenges. First of all, synchronization does not come for free anymore. If you change the mentioned password your team members and your deployed services need to know. This means, you need a way to distribute this secret file onto your servers and to everyone who will actually deploy. Besides that, you have an unencrypted file on the file system of your server which again contains all your precious secrets. In addition you can pretty easily run into a lockstep scenario where you have to make sure that you deploy dependant changes to the config and the source code simultaneously.</p>
<p>To completely eradicate files for reading secrets one can make use of environment variables (see [12factor app][12factor_env]):</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> PASSWORD <span class="op">=</span> <span class="va">process</span>.<span class="va">env</span>.<span class="at">PASSWORD</span></code></pre></div>
<p>An approach like this will keep clear text secrets away from your committed source code and away from the file system of your deployments. In addition to this, it gives you configurable deploys. This means that you are able to deploy your code to as much environments as you want.</p>
<p>But it still leaves you the burden of finding a way to securely set these values during deployment and distribute them among your team.</p>
<p>All three approaches seem like a trade-off. You have to decide between the ability to synchronize secrets after rotating them, and the safety of their storage.</p>
<p>This means we need some kind of synchronized shared password store that is encrypted and can be decrypted by every team-member individually. Of course, without the need for one well-known shared password. So before diving into a concrete example, let’s have a look at some possible tools to support our needs.</p>
<h2 id="a-short-sidetrack-about-gpg">A short sidetrack about GPG</h2>
<p><a href="https://gnupg.org/">GPG (GNU Privacy Guard)</a> is an implementation of a PKI (Public Key Infrastructure). You may already have heard of it in the context of email encryption. If you create a GPG certificate it will contain correlating public and private keys – also referred to as “asymmetric crypto”. In addition, such a certificate will contain a unique GPG ID that can be used to refer to it. Everything that gets encrypted with that public key can only be decrypted by using the corresponding private key.</p>
<p>This means, you can share your public key with peers so that they are enabled to send you secret information that no one can decrypt without your (securely stored and password protected) private key.</p>
<p>While GPG embodies more features, like for example digital signatures, the described public key encryption is the important one for the examples to come.</p>
<p>If you want to get started with GPG there is a good <a href="https://spin.atomicobject.com/2013/09/25/gpg-gnu-privacy-guard/">beginner tutorial</a> online.</p>
<h2 id="introducing-pass">Introducing pass</h2>
<p>The password manager <a href="https://www.passwordstore.org/">pass</a> on the other hand is a neat little utility that basically comprises a convenient wrapper around GPG. It allows to encrypt secret information with either one or several public GPG keys. This enables more than one person to decrypt contained secrets at the same time.</p>
<p>All these secrets are stored encrypted inside of one directory. This directory can now easily be shared using a version control system.</p>
<p>We will this utility in our example application to establish an encrypted pool of secret information without relying on shared secrets like a well-known password.</p>
<p><code>pass</code> itself is actually quite easy to acquire. You can simply install it using your favourite package manager:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="ex">brew</span> install pass
<span class="fu">sudo</span> apt-get install pass
<span class="fu">sudo</span> pacman -S pass
<span class="ex">...</span></code></pre></div>
<h2 id="an-example-application">An example Application</h2>
<p>We want to build a status page that interactively displays some statistics about a certain github user. To do so, the username and an access token is needed. These are the shared secrets we will have to take care of.</p>
<p>Everything will be hosted on a PaaS hoster to simplify and streamline as much of the infrastructure as possible. PaaS stands for ‘Platform as a Service’. It basically means that you won’t have to manage bare metal servers or virtual machines. Instead, deployment occurs on an application basis. Scaling, load balancing and stuff like e.g. database integration is taken care of by the hoster. One of the simplest PaaS hoster I know is <a href="https://www.heroku.com/">heroku</a>.</p>
<p>There is a good tutorial on how to setup your own <a href="https://devcenter.heroku.com/start">heroku application</a>.</p>
<p>The simplest possible JavaScript application that is deployable on heroku consists of three files: the package definition, the process definition and the actual server file:</p>
<p>The package description is mainly needed to contain a list of dependencies so that the heroku app server can download them prior to starting:</p>
<div class="sourceCode"><pre class="sourceCode json"><code class="sourceCode json"><span class="fu">{</span>
  <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;devseccon-secrets&quot;</span><span class="fu">,</span>
  <span class="dt">&quot;version&quot;</span><span class="fu">:</span> <span class="st">&quot;1.0.0&quot;</span><span class="fu">,</span>
  <span class="dt">&quot;main&quot;</span><span class="fu">:</span> <span class="st">&quot;index.js&quot;</span><span class="fu">,</span>
  <span class="dt">&quot;license&quot;</span><span class="fu">:</span> <span class="st">&quot;ISC&quot;</span><span class="fu">,</span>
  <span class="dt">&quot;dependencies&quot;</span><span class="fu">:</span> <span class="fu">{</span>
    <span class="dt">&quot;express&quot;</span><span class="fu">:</span> <span class="st">&quot;^4.14.0&quot;</span>
  <span class="fu">}</span>
<span class="fu">}</span></code></pre></div>
<p>The Procfile defines the processes which need to be running in order for the application to function. In this case, this is just the server backend:</p>
<div class="sourceCode"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span class="fu">web:</span><span class="at"> node index.js</span></code></pre></div>
<p>The actual server endpoint is located in the <code>index.js</code> file and build on top of <code>express.js</code>. <code>express</code> is a pretty common JavaScript http server framework. The app is configured using three environment variables. Two of these are the github credentials used to authenticate against the github API. The third is the HTTP port on which the application server will listen on.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">var</span> express <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;express&#39;</span>)
<span class="kw">var</span> app <span class="op">=</span> <span class="at">express</span>()

<span class="kw">var</span> user <span class="op">=</span> <span class="va">process</span>.<span class="va">env</span>.<span class="at">GITHUB_USER</span>
<span class="kw">var</span> apiToken <span class="op">=</span> <span class="va">process</span>.<span class="va">env</span>.<span class="at">GITHUB_API_TOKEN</span>

<span class="kw">var</span> port <span class="op">=</span> <span class="va">process</span>.<span class="va">env</span>.<span class="at">PORT</span> <span class="op">||</span> <span class="dv">5000</span>

<span class="va">app</span>.<span class="at">get</span>(<span class="st">&#39;/&#39;</span><span class="op">,</span> <span class="kw">function</span> (req<span class="op">,</span> res) <span class="op">{</span>
  <span class="co">// Implement GitHub API call</span>
<span class="op">}</span>)

<span class="va">app</span>.<span class="at">listen</span>(port<span class="op">,</span> <span class="kw">function</span> () <span class="op">{</span>
  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;App listening on port &#39;</span> <span class="op">+</span> port)
<span class="op">}</span>)</code></pre></div>
<p>Heroku itself deploys using git. To trigger the deployment simply push to the heroku origin created during setup:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="fu">git</span> push heroku master:master</code></pre></div>
<p>In principle, this is all you have to do to get the application up an running. But since we are referring to two environment variables for our credentials (<code>GITHUB_USER</code> and <code>GITHUB_API_TOKEN</code>) we have to initialize them prior to startup.</p>
<p>The heroku tool allows us to explicitly trigger an application restart while persistently setting certain environment variables from command-line:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="ex">heroku</span> config:set GITHUB_USER=<span class="st">&quot;holderbaum&quot;</span> \
                    GITHUB_API_TOKEN=<span class="st">&quot;sn4k3oil&quot;</span></code></pre></div>
<p>This approach is taking us into a good direction. It removes hard-coded secrets from any files, be it source code or configuration.</p>
<p>But still, to execute this configuration command, I need to manually type all needed secrets into my terminal. And that is true for every person that should be able to deploy. Our challenge is not completely solved, yet.</p>
<p>So we need a way to retrieve these secret information automatically. Let’s use <code>pass</code> to build a secret store.</p>
<h2 id="using-pass-for-secret-values">Using pass for secret values</h2>
<p>As mentioned before, <code>pass</code> mainly operates on a single directory which we will call the secret store. To initialize such a store you have to set its path in form of an environment variable and then simply initialize it by calling <code>pass</code>. We will initialize the store with my personal GPG ID only to further simplify the example:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="bu">export</span> <span class="va">PASSWORD_STORE_DIR=</span>~/code/app/secrets
$ <span class="bu">export</span> <span class="va">MY_ID=</span>5244D411CD7CBA95
$ <span class="ex">pass</span> init <span class="va">$MY_ID</span></code></pre></div>
<p>The argument provided to the <code>pass init</code> call is my GPG ID. You can pass an arbitrary list of IDs to the <code>init</code> call. Every GPG ID will be able to decrypt the contents of the store. Now adding values to the store is even simpler. <code>pass</code> provides an <code>add</code> command that can read from stdin:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="bu">export</span> <span class="va">PASSWORD_STORE_DIR=</span>~/code/app/secrets
$ <span class="ex">pass</span> add production/user
$ <span class="ex">pass</span> add production/api_token</code></pre></div>
<p>After adding it to the secret store one can easily decrypt it as long as the GPG certificate of the given ID is yours. To do so just utilize <code>pass show</code>. This command will print the decrypted secret on <code>stdout</code> for easy usage and scriptability. It can be used like this to further improve the deployment configuration call:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="bu">export</span> <span class="va">PASSWORD_STORE_DIR=</span>~/code/app/secrets
$ <span class="ex">pass</span> show production/api_token
<span class="st">&quot;sn4k3oil&quot;</span></code></pre></div>
<p>So far we achieved having a password store that is living in a single directory and based on flat files that can be shared using version control. The <code>~/Code/myapp/secrets</code> dir now looks like this:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="fu">find</span> ~/code/app/secrets

<span class="ex">~/code/app/secrets/.gpg_id</span>
<span class="ex">~/code/app/secrets/production/user.gpg</span>
<span class="ex">~/code/app/secrets/production/api_token.gpg</span></code></pre></div>
<p>The <code>*.gpg</code> files contain the encrypted secrets that had been added previously. The <code>.gpg_id</code> file contains the list of GPG IDs that are used to encrypt the contents of the store. It is even possible to use different <code>.gpg_id</code> files for different subdirectories. This feature can enable different access policies per directory (e.g. certain secrets are only readable by a part of the team).</p>
<p>Of course, you don’t have to use a tool like <code>find</code> to display the content of such a secret store. You can simply call <code>pass ls</code> for that:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="bu">export</span> <span class="va">PASSWORD_STORE_DIR=</span>~/code/app/secrets
$ <span class="ex">pass</span> ls
<span class="ex">+--</span> production
    <span class="kw">|</span><span class="ex">--</span> api_token
    <span class="ex">+--</span> user</code></pre></div>
<p>The previously seen <code>pass show</code> call can be combined with the <code>heroku config:set</code> call to deploy without typing explicit secrets:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="bu">export</span> <span class="va">PASSWORD_STORE_DIR=</span>~/code/app/secrets
$ <span class="bu">export</span> <span class="va">USER=</span><span class="kw">`</span><span class="ex">pass</span> show production/user<span class="kw">`</span>
$ <span class="bu">export</span> <span class="va">TOKEN=</span><span class="kw">`</span><span class="ex">pass</span> show production/api_token<span class="kw">`</span>
$ <span class="ex">heroku</span> config:set GITHUB_USER=<span class="va">$USER</span> \
                    GITHUB_API_TOKEN=<span class="va">$TOKEN</span></code></pre></div>
<p>So far, we have accomplished a secret store only accessible for a single person. But the goal was to be able to share secrets inside the team. That means, we are not done yet!</p>
<h2 id="working-with-a-team">Working with a Team</h2>
<p>The example above operated only with one GPG ID. This is useful for a personal project without an actual team. When working with teams we usually talk about two different points in time that have – beside other implications – an impact on security: <strong>Roll On</strong> and <strong>Roll Off</strong></p>
<h2 id="handling-roll-on-of-a-new-team-member">Handling ‘Roll On’ of a new Team Member</h2>
<p>Rolling On means that an additional person joins the trusted circle of team members. 100 24550  100 24550    0     0  24550      0  0:00:01 --:--:--  0:00:01 71994
This involves in general granting certain privileges to that person like access to project secrets and/or infrastructure. It is a good thing to have a Roll On Security Checklist on your project to handle such a scenario. Nevertheless, when a person joins, beside other tasks, access to secrets needs to be ensured. <code>pass</code> makes this no effort at all.</p>
<p>Just get the new members GPG ID and Public Key and call init again with all IDs including the new one. Everything will be re-encrypted accordingly:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="bu">export</span> <span class="va">PASSWORD_STORE_DIR=</span>~/code/app/secrets
$ <span class="bu">export</span> <span class="va">MY_ID=</span>5244D411CD7CBA95
$ <span class="bu">export</span> <span class="va">ADAS_ID=</span>44A7B1E354AF81E2
$ <span class="bu">export</span> <span class="va">ALANS_ID=</span>BA29EE533AF39B21
$ <span class="ex">pass</span> init <span class="va">$MY_ID</span> <span class="va">$ADAS_ID</span> <span class="va">$ALANS_ID</span></code></pre></div>
<p>On account of the secret store access this is all there is to be done. This procedure can be repeated every time a new member joins. Note, that you need to have the GPG public key in your local GPG key ring in order to be able to encrypt with it.</p>
<p>This means, you have to make sure, that every member of your team is in possession of every public key that is used inside your team.</p>
<h2 id="handling-roll-off-of-a-leaving-team-member">Handling ‘Roll Off’ of a leaving Team Member</h2>
<p>Leaving the team on the other hand generates more work. Changing access to the secret store is easy. Just call <code>init</code> again but leave out the GPG ID of the leaving member this time.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="bu">export</span> <span class="va">PASSWORD_STORE_DIR=</span>~/code/app/secrets
$ <span class="bu">export</span> <span class="va">MY_ID=</span>5244D411CD7CBA95
$ <span class="bu">export</span> <span class="va">ADAS_ID=</span>44A7B1E354AF81E2
$ <span class="ex">pass</span> init <span class="va">$MY_ID</span> <span class="va">$ADAS_ID</span></code></pre></div>
<p>But this won’t make the secrets used up until now magically unknown to the leaving person. The only assurance you get is that the left member won’t be able to decrypt secrets from now on should they get a hold of the secret store directory. The history of the secret store – meaning: all previously encrypted secrets – will still be decryptable for them.</p>
<p>This implies that the change of secret information (like passwords or API tokens) should be a dedicated step on your Roll Off Checklist.</p>
<p>But since you can keep your secrets in one dedicated place, rotating them after a Roll Off becomes less of a challenge.</p>
<h2 id="conclusion">Conclusion</h2>
<p>We have built an encrypted secret store in a single directory. This directory can be distributed amongst your team members like regular source code, e.g. by checking it into version control. This will even give us a versioned secret store. Because of the nature of pass, the process of people joining or leaving the team becomes as streamlined as possible, without compromising security.</p>

<div class="article-details-footer">
<a class="button all-articles-link" href="/articles/">Browse all Articles</a>
</div>

</div>
</section>

  <footer class="contact-section section-dark">
    <div class="container">
      <h2>You should get in touch with me.</h2>
      <hr class="headline-separator"/>
      <div class="row">
        <div class="six columns">
          <form>
            <label for="name">Your Name</label>
            <input class="u-full-width" id="name" type="text"/>
            <label for="email">Your E-Mail</label>
            <input class="u-full-width" id="email" type="email"/>
            <label for="message">Your Message</label>
            <textarea class="u-full-width" rows="8" id="message"></textarea>
            <label class="send-copy">
              <input type="checkbox">
              <span class="label-body">Send a copy to yourself</span>
            </label>
            <input class="button-primary button-send" value="Submit" type="submit">
          </form>
        </div>
        <div class="six columns">
          <ul>
            <li class="contact-address">
              <div>
                Holderbaum Consulting<br/>
                Adolphstrasse 18<br/>
                50679 Köln
              </div>
            </li>
            <li class="contact-phone">
              <a href="tel:+4917663729771">+49 176 / 637 297 71</a>
            </li>
            <li class="contact-mail">
              <a href="mailto:contact@holderbaum.io">contact@holderbaum.io</a>
            </li>
            <li class="contact-gpg">
              <div>
                199A F24A 8B27 D53F 0B1F<br/>
                2B5A 094D B6B8 2E06 5EBD
              </div>
            </li>
            <li class="contact-twitter">
              <a href="https://twitter.com/hldrbm">
                twitter.com/hldrbm
              </a>
            </li>
            <li class="contact-github">
              <a href="https://github.com/holderbaum">
                github.com/holderbaum
              </a>
            </li>
          </ul>
        </div>
      </div>
    </div>
  </footer>
</body>
</html>
